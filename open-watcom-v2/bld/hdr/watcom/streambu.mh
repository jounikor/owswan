///////////////////////////////////////////////////////////////////////////
// FILE: streambuf/streambuf.h (streambuf support)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library. It
//              declares the streambuf base class.
///////////////////////////////////////////////////////////////////////////
:segment !CNAME
#ifndef _STREAMBUF_H_INCLUDED
#define _STREAMBUF_H_INCLUDED

:include readonly.sp

#ifndef _STREAMBUF_INCLUDED
 #include <streambuf>
#endif
using std::streambuf;

// All included names should also be in the global namespace.
#ifndef _STDDEF_H_INCLUDED
 #include <stddef.h>
#endif

#ifndef _STRING_H_INCLUDED
 #include <string.h>
#endif

#endif
:elsesegment
#ifndef _STREAMBUF_INCLUDED
#define _STREAMBUF_INCLUDED

:include readonly.sp

:include cpponly.sp

:include owrtlink.sp

#ifndef _CSTDDEF_INCLUDED
 #include <cstddef>
#endif

#ifndef _CSTRING_INCLUDED
 #include <cstring>
#endif

:include cpplock.sp

#define __char_to_int( __c )    ((int)(unsigned char)(__c))

:include nsstd.sp
  // **************************** STREAMBUF **********************************
:include pshpackl.sp
  class _WPRTLINK streambuf {
  public:
    streamsize  in_avail() const;
    int  out_waiting() const;
    int  snextc();
    streamsize sgetn( char *__buf, streamsize __len );
    int  speekc();
    int  sgetc();
    int  sgetchar();
    int  sbumpc();
    void stossc();
    int  sputbackc( char __c );
    int  sputc( int __c );
    streamsize sputn( char const *__buf, streamsize __len );
    void dbp();

    virtual streamsize do_sgetn( char *__buf, streamsize __len );
    virtual streamsize do_sputn( char const *__buf, streamsize __len );
    virtual int        pbackfail( int __ignored );
    virtual int        overflow( int = EOF ) = 0;
    virtual int        underflow() = 0;
    virtual streambuf *setbuf( char *__buf, streamsize __len );
    virtual streampos  seekoff( streamoff     __ignored1,
                                ios::seekdir  __ignored2,
                                ios::openmode __ignored3 = ios::in | ios::out );
    virtual streampos  seekpos( streampos     __position,
                                ios::openmode __mode = ios::in | ios::out );
    virtual int        sync();

    __lock *__b_lock;       // streambuf data member operations

  protected:
    streambuf();
    streambuf( char *__buf, int __len );
    virtual ~streambuf();

    int   allocate();
    char *base() const;
    char *ebuf() const;
    int   blen() const;
    void  setb( char *__buf, char *__endbuf, int __autodelete = 0 );
    char *eback() const;
    char *gptr() const;
    char *egptr() const;
    void  gbump( streamoff __offset );
    void  setg( char *__eback, char *__gptr, char *__egptr );
    char *pbase() const;
    char *pptr() const;
    char *epptr() const;
    void  pbump( streamoff __offset );
    void  setp( char *__pptr, char *__epptr );
    int   unbuffered( int __unbuffered );
    int   unbuffered() const;

    virtual int doallocate();

  private:
    // Declared but not defined, to prevent copying a streambuf.
    streambuf( streambuf & );
    void operator = ( streambuf & );

    char *__reserve_base;
    char *__reserve_end;
    char *__get_base;
    char *__get_end;
    char *__get_ptr;
    char *__put_base;
    char *__put_end;
    char *__put_ptr;
    unsigned  __unbuffered_state : 1;
    unsigned  __delete_reserve   : 1;
  };
:include poppack.sp

  // *********************** Reserve area inline functions *******************

  inline char *streambuf::base() const {
    return( __reserve_base );
  }

  inline char *streambuf::ebuf() const {
    return( __reserve_end );
  }

  inline int streambuf::blen() const {
    __lock_it( __b_lock );
    return( (int)(__reserve_end - __reserve_base) );
  }

  inline int streambuf::allocate() {
    __lock_it( __b_lock );
    return( (base() != NULL || unbuffered()) ? __NOT_EOF : doallocate() );
  }

  inline int streambuf::unbuffered() const {
    return( __unbuffered_state );
  }

  inline int streambuf::unbuffered( int __unbuffered ) {
    __lock_it( __b_lock );
    int __old_unbuffered = __unbuffered_state;
    __unbuffered_state   = __unbuffered ? 1 : 0;
    return( __old_unbuffered );
  }

  // *********************** Get area inline functions ***********************

  inline char * streambuf::eback() const {
    return( __get_base );
  }

  inline char * streambuf::gptr() const {
    return( __get_ptr );
  }

  inline char * streambuf::egptr() const {
    return( __get_end );
  }

  inline void streambuf::gbump( streamoff __offset ) {
    __lock_it( __b_lock );
    __get_ptr += __offset;
  }

  inline void streambuf::setg( char *__eback, char *__gptr, char *__egptr ) {
    __lock_it( __b_lock );
    __get_base = __eback;
    __get_ptr  = __gptr;
    __get_end  = __egptr;
  }

  // *********************** Put area inline functions ***********************

  inline char * streambuf::pbase() const {
    return( __put_base );
  }

  inline char * streambuf::pptr() const {
    return( __put_ptr );
  }

  inline char * streambuf::epptr() const {
    return( __put_end );
  }

  inline void streambuf::pbump( streamoff __offset ) {
    __lock_it( __b_lock );
    __put_ptr += __offset;
  }

  inline void streambuf::setp( char *__pptr, char *__epptr ) {
    __lock_it( __b_lock );
    __put_base = __pptr;
    __put_ptr  = __pptr;
    __put_end  = __epptr;
  }

  // *********************** Inline input functions **************************

  inline streamsize streambuf::in_avail() const {
    __lock_it( __b_lock );
    return( (streamsize)(__get_end - __get_ptr) );
  }

  inline int streambuf::sgetchar() {
    __lock_it( __b_lock );
    return( (__get_ptr >= __get_end) && (underflow() == EOF) ? EOF
                                                             : __char_to_int( *__get_ptr++ ) );
  }

  inline int streambuf::sbumpc() {
    return( sgetchar() );
  }

  inline int streambuf::snextc() {
    __lock_it( __b_lock );
    return( (__get_ptr) && (++__get_ptr < __get_end) ? __char_to_int( *__get_ptr )
                                                     : underflow() );
  }

  inline int streambuf::speekc() {
    __lock_it( __b_lock );
    return( (__get_ptr < __get_end) ? __char_to_int( *__get_ptr )
                                    : underflow() );
  }

  inline int streambuf::sgetc() {
    return( speekc() );
  }

  inline streamsize streambuf::sgetn( char *__buf, streamsize __len ) {
    __lock_it( __b_lock );
    if( __len < (streamsize)(__get_end - __get_ptr) ) {
        memcpy( __buf, __get_ptr, __len );
        gbump( __len );
        return( __len );
    }
    return( do_sgetn( __buf, __len ) );
  }

  inline void streambuf::stossc() {
    __lock_it( __b_lock );
    if( (__get_ptr < __get_end) || (underflow() != EOF) ) {
        ++__get_ptr;
    }
  }

  // *********************** Inline output functions *************************

  inline int streambuf::out_waiting() const {
    __lock_it( __b_lock );
    return( (int)(__put_ptr - __put_base) );
  }

  inline int streambuf::sputbackc( char __c ) {
    __lock_it( __b_lock );
    return( (__get_ptr > __get_base) ? __char_to_int( *--__get_ptr = __c )
                                     : pbackfail( __char_to_int( __c ) ) );
  }

  inline int streambuf::sputc( int __c ) {
    __lock_it( __b_lock );
    return( (__put_ptr >= __put_end) ? overflow( __c )
                                     : __char_to_int( *__put_ptr++ = (char)__c ) );
  }

  inline streamsize streambuf::sputn( char const *__buf, streamsize __len ) {
    __lock_it( __b_lock );
    if( __len < (streamsize)(__put_end - __put_ptr) ) {
        memcpy( __put_ptr, __buf, __len );
        pbump( __len );
        return( __len );
    }
    return( do_sputn( __buf, __len ) );
  }
:include nsstdepi.sp

#endif
:endsegment
