/****************************************************************************
*
*                            Open Watcom Project
*
* Copyright (c) 2002-2022 The Open Watcom Contributors. All Rights Reserved.
*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
*
*  ========================================================================
*
*    This file contains Original Code and/or Modifications of Original
*    Code as defined in and that are subject to the Sybase Open Watcom
*    Public License version 1.0 (the 'License'). You may not use this file
*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
*    provided with the Original Code and Modifications, and is also
*    available at www.sybase.com/developer/opensource.
*
*    The Original Code and all software distributed under the License are
*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
*    NON-INFRINGEMENT. Please see the License for the specific language
*    governing rights and limitations under the License.
*
*  ========================================================================
*
* Description:  Generate scaffolding for autogenerated option parsing.
*
****************************************************************************/


#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <limits.h>
#include "bool.h"
#include "lsspec.h"
#include "encodlng.h"
#include "cvttable.h"

#include "clibext.h"


/* following must be ordered as US ASCII */
#define OPT_TAGS \
TAG( ARGEQUAL ) \
TAG( CHAIN ) \
TAG( CHAR ) \
TAG( CMT ) \
TAG( CODE ) \
TAG( ENUMERATE ) \
TAG( FILE ) \
TAG( FOOTER ) \
TAG( FOOTERU ) \
TAG( GROUP ) \
TAG( ID ) \
TAG( IMMEDIATE ) \
TAG( INTERNAL ) \
TAG( JFOOTER ) \
TAG( JFOOTERU ) \
TAG( JTITLE ) \
TAG( JTITLEU ) \
TAG( JUSAGE ) \
TAG( MULTIPLE ) \
TAG( NEGATE ) \
TAG( NOCHAIN ) \
TAG( NOEQUAL ) \
TAG( NTARGET ) \
TAG( NUMBER ) \
TAG( OPTION ) \
TAG( OPTIONAL ) \
TAG( PATH ) \
TAG( PREFIX ) \
TAG( SPECIAL ) \
TAG( TARGET ) \
TAG( TIMESTAMP ) \
TAG( TITLE ) \
TAG( TITLEU ) \
TAG( USAGE ) \
TAG( USAGEGRP ) \
TAG( USAGEOGRP )

#define NEXT_ARG() \
        --argc1; ++argv1

#define NEXT_ARG_CHECK() \
        --argc1; ++argv1; if( argc1 < NUM_FILES ) { return( true ); }

#define NOSKIP( s )     (s[0] != '.' || s[1] != '\0')

// functions that are supplied by the host environment
#define FN_UNGET            "OPT_UNGET"                 // void ( void )
#define FN_GET_LOWER        "OPT_GET_LOWER"             // int ( void )
#define FN_RECOG            "OPT_RECOG"                 // bool ( int )
#define FN_RECOG_LOWER      "OPT_RECOG_LOWER"           // bool ( int )
#define FN_END              "OPT_END"                   // bool ( void )

#define FN_NUMBER           "OPT_GET_NUMBER"            // bool ( unsigned * )
#define FN_NUMBER_DEFAULT   "OPT_GET_NUMBER_DEFAULT"    // bool ( unsigned *, unsigned )
#define FN_NUMBER_MULTIPLE  "OPT_GET_NUMBER_MULTIPLE"   // bool ( OPT_NUMBER ** )
#define FN_CHAR             "OPT_GET_CHAR"              // bool ( int * )
#define FN_CHAR_OPT         "OPT_GET_CHAR_OPT"          // bool ( int * )
#define FN_ID               "OPT_GET_ID"                // bool ( OPT_STRING ** )
#define FN_ID_OPT           "OPT_GET_ID_OPT"            // bool ( OPT_STRING ** )
#define FN_FILE             "OPT_GET_FILE"              // bool ( OPT_STRING ** )
#define FN_FILE_OPT         "OPT_GET_FILE_OPT"          // bool ( OPT_STRING ** )
#define FN_PATH             "OPT_GET_PATH"              // bool ( OPT_STRING ** )
#define FN_PATH_OPT         "OPT_GET_PATH_OPT"          // bool ( OPT_STRING ** )

#define FN_CLEAN_STRING     "OPT_CLEAN_STRING"          // void ( OPT_STRING ** )
#define FN_CLEAN_NUMBER     "OPT_CLEAN_NUMBER"          // void ( OPT_NUMBER ** )

#define FN_PROCESS          "OPT_PROCESS"               // bool ( OPT_STORAGE * )
#define FN_INIT             "OPT_INIT"                  // void ( OPT_STORAGE * )
#define FN_FINI             "OPT_FINI"                  // void ( OPT_STORAGE * )

#define USE_SWITCH_THRESHOLD    (4)
#define CONSOLE_WIDTH           (79)

#define BUFF_SIZE               1024

#define HAS_OPT_STRING( o )     ( (o)->is_id || (o)->is_file || (o)->is_path || (o)->is_special )
#define HAS_OPT_NUMBER( o )     ( (o)->is_number && (o)->is_multiple )

#define NOCHAIN                 ((CHAIN *)(pointer_uint)-1)

#define mytolower(c)            ((c < 'A' || c > 'Z') ? c : c - 'A' + 'a')
#define myisspace(c)            (c == ' ' || c == '\t')

#define IS_SELECTED(s)          ((s->target_mask & targetMask) && (s->ntarget_mask & targetMask) == 0)

#define IS_ASCII(c)             (c < 0x80)

#define GET_OUTPUT_BUF(l)       (outputbuff + l * BUFF_SIZE)

#define SKIP_SPACES(s)          while( myisspace( *s ) ) s++

typedef const char              *lang_data[LANG_MAX];

typedef unsigned long           targmask;

typedef int (*comp_fn)(const void *,const void *);

typedef void process_line_fn( void );

typedef enum tag_id {
    #define TAG( s )        TAG_##s ,
    OPT_TAGS
    #undef TAG
    TAG_UNKNOWN,
    TAG_NULL
} tag_id;

typedef enum flow_control {
    EC_NULL             = 0,
    EC_CONTINUE         = 0x01,
    EC_CHAIN            = 0x02
} flow_control;

typedef enum cvt_name {
    CVT_NAME,
    CVT_PATTERN,
    CVT_USAGE
} cvt_name;

typedef struct target {
    targmask        mask;
    const char      *name;
} TARGET;

typedef struct name {
    struct name     *next;
    boolbit         is_timestamp : 1;
    char            name[1];
} NAME;

typedef struct title {
    struct title    *next;
    targmask        target_mask;
    targmask        ntarget_mask;
    boolbit         is_titleu   : 1;
    lang_data       lang_title;
    lang_data       lang_titleu;
} TITLE;

typedef struct chain {
    struct chain    *next;
    lang_data       Usage;
    size_t          name_len;
    size_t          pattern_len;
    boolbit         usage_used : 1;
    boolbit         code_used  : 1;
    char            pattern[1];
} CHAIN;

typedef struct group {
    struct group    *next;
    lang_data       Usage;
    char            pattern[1];
} GROUP;


typedef struct option {
    struct option   *next;
    struct option   *synonym;
    lang_data       lang_usage;
    char            *check_func;
    char            *special_func;
    char            *immediate_func;
    char            *usage_argid;
    char            *field_name;
    char            *value_field_name;
    NAME            *enumerate;
    char            *code;
    unsigned        number_default;
    targmask        target_mask;
    targmask        ntarget_mask;
    boolbit         default_specified : 1;
    boolbit         is_simple         : 1;
    boolbit         is_immediate      : 1;
    boolbit         is_code           : 1;
    boolbit         is_internal       : 1;
    boolbit         is_multiple       : 1;
    boolbit         is_number         : 1;
    boolbit         is_id             : 1;
    boolbit         is_char           : 1;
    boolbit         is_file           : 1;
    boolbit         is_optional       : 1;
    boolbit         is_path           : 1;
    boolbit         is_special        : 1;
    boolbit         is_prefix         : 1;
    boolbit         is_timestamp      : 1;
    boolbit         is_negate         : 1;
    CHAIN           *chain;
    GROUP           *group;
    size_t          name_len;
    char            *name;
    char            pattern[1];
} OPTION;

typedef struct codeseq {
    struct codeseq  *sibling;
    struct codeseq  *children;
    OPTION          *option;
    char            c;
    boolbit         sensitive  : 1;
    boolbit         accept     : 1;
    boolbit         chain      : 1;
    boolbit         chain_root : 1;
} CODESEQ;

static unsigned     line;
static FILE         *gfp;
static FILE         *ofp;
static FILE         *pfp;
static FILE         *ufp;
static FILE         *mfp;
static FILE         *bfp;

static char         ibuff[BUFF_SIZE];
static char         tagbuff[BUFF_SIZE];
static char         tokbuff[BUFF_SIZE];
static char         tmpbuff[BUFF_SIZE];
static char         hdrbuff[BUFF_SIZE];
static char         maxusgbuff[BUFF_SIZE];

static char         alternateEqual;
static CHAIN        *lastChain;
static GROUP        *lastGroup;
static size_t       maxUsageLen;
static targmask     targetMask = 0;
static targmask     targetAnyMask;
static targmask     targetDbgMask;

static tag_id getsUsage = TAG_NULL;

static char         *outputbuff = NULL;
static lang_data    outputdata;

static int          fno = 0;

#define TAGS_COUNT  (sizeof( tagNames ) / sizeof( tagNames[0] ))
static const char *tagNames[] = {
    #define TAG( s )        #s ,
    OPT_TAGS
    #undef TAG
};

#define TAG( s )        static void do##s( const char * );
OPT_TAGS
#undef TAG

static void (*processTag[])( const char * ) = {
    #define TAG( s )        do##s ,
    OPT_TAGS
    #undef TAG
    NULL
};

#define TARGETS_COUNT  (sizeof( validTargets ) / sizeof( validTargets[0] ))
static const char *validTargets[] = {
/* default targets */
    "any",
    "dbg",
/* architecture targets */
    "i86",
    "386",
    "x64",
    "axp",
    "ppc",
    "mps",
    "sparc",
/* host OS targets */
    "bsd",
    "dos",
    "linux",
    "nov",          /* Netware */
    "nt",
    "os2",
    "osx",
    "pls",          /* DOS Pharlap extender */
    "qnx",
    "rsi",          /* DOS DOS4G extender */
    "haiku",
    "rdos",
    "win",
/* extra targets */
    "targ1",
    "targ2"
};

static const char * const langName[] = {
    #define LANG_DEF( id, dbcs )        #id ,
    LANG_DEFS
    #undef LANG_DEF
};

static uint_8 const langMaxChar[] = {
    #define LANG_DEF( id, dbcs )        dbcs ,
    LANG_DEFS
    #undef LANG_DEF
};

/*
 * Shift-JIS (CP932) lead byte ranges
 * 0x81-0x9F
 * 0xE0-0xFC
 */
static cvt_chr cvt_table_932[] = {
    #define pickb(s,u) {s, u},
    #define picki(s,u)
    #include "cp932uni.h"
    #undef picki
    #undef pickb
};

static const char *usageMsg[] = {
    "optencod [options] <gml-file> <parser-h> <parser-c> <usage-h> <target>*",
    "",
    "Options:",
    "  -c comma separated list",
    "  -i create international file with non-english data",
    "  -l=<lang-n> is the language(number) used for output data",
    "  -n zero terminated items",
    "  -q quiet operation",
    "  -rc=<macro-name> generate files for resource compiler",
    "  -u=<usage-u> is the output file for the QNX usage file",
    "  -utf8 output text use UTF-8 encoding",
    "",
    "    <gml-file> is the tagged input GML file",
    "    <parser-h> is the output file for the command line parser data declaration",
    "    <parser-c> is the output file for the command line parser code",
    "    <usage-h> is the output file for the usage string file",
    "    <target> can be chosen from:",
    NULL
};

static struct {
    boolbit     international   : 1;
    boolbit     quiet           : 1;
    boolbit     no_equal        : 1;
    boolbit     alternate_equal : 1;
    boolbit     zero_term       : 1;
    boolbit     rc              : 1;
    boolbit     out_utf8        : 1;
    boolbit     comma_list      : 1;
    char        *rc_macro;
    language_id lang;
} optFlag;

static TARGET   *targetList;
static NAME     *enumList;
static NAME     *enumeratorList;
static OPTION   *optionList;
static OPTION   *uselessOptionList;
static TITLE    *titleList;
static TITLE    *footerList;
static CHAIN    *chainList;
static GROUP    *groupList = NULL;
static TITLE    *targetTitle;
static TITLE    *targetFooter;

static void emitCode( CODESEQ *h, unsigned depth, flow_control control );

static int mystricmp( const char *p1, const char *p2 )
{
    while( mytolower( *p1 ) == mytolower( *p2 ) ) {
        if( *p1 == '\0') {
            return( 0 );
        }
        p1++; p2++;
    }
    return( mytolower( *p1 ) - mytolower( *p2 ) );
}

#if 0
static int compare_enc( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->s - p2->s );
}
#endif

static int compare_utf8( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->u - p2->u );
}

static size_t utf8_to_cp932( const char *src, char *dst )
{
    size_t      i;
    size_t      o;
    size_t      src_len;
    cvt_chr     x;
    cvt_chr     *p;

    src_len = strlen( src );
    o = 0;
    for( i = 0; i < src_len && o < BUFF_SIZE - 6; i++ ) {
        x.u = (unsigned char)src[i];
        if( IS_ASCII( x.u ) ) {
            /*
             * ASCII (0x00-0x7F), no conversion
             */
            dst[o++] = (char)x.u;
        } else {
            /*
             * UTF-8 to UNICODE conversion
             */
            if( (x.u & 0xF0) == 0xE0 ) {
                x.u &= 0x0F;
                x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            } else {
                x.u &= 0x1F;
            }
            x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            /*
             * UNICODE to CP932 encoding conversion
             */
            p = bsearch( &x, cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
            if( p == NULL ) {
                fprintf( stderr, "unknown unicode character: 0x%4.4X\n", x.u );
                x.s = '?';
            } else {
                x.s = p->s;
            }
            if( x.s > 0xFF ) {
                /* write lead byte first */
                dst[o++] = (char)(x.s >> 8);
            }
            dst[o++] = (char)x.s;
        }
    }
    dst[o] = '\0';
    return( o );
}

static const char *getLangData( lang_data langdata, language_id lang )
{
    const char *p;

    p = langdata[lang];
    if( p == NULL || *p == '\0' ) {
        p = langdata[LANG_English];
    }
    return( p );
}

static void outputInit( void )
{
    int i;
    char *p;

    p = outputbuff = calloc( LANG_MAX, BUFF_SIZE );
    for( i = 0; i < LANG_MAX; i++ ) {
        outputdata[i] = p;
        p += BUFF_SIZE;
    }
}

static void outputFini( void )
{
    free( outputbuff );
}

#if defined( __WATCOMC__ )
#pragma abort   fail
#endif
static void fail( const char *msg, ... )
{
    va_list args;

    if( line ) {
        fprintf( stderr, "error on line %u\n", line );
    }
    va_start( args, msg );
    vfprintf( stderr, msg, args );
    va_end( args );
    exit( EXIT_FAILURE );
}

static void dumpUsage( void )
{
    const char **p;
    int        i;

    for( p = usageMsg; *p != NULL; ++p ) {
        fprintf( stderr, "%s\n", *p );
    }
    fprintf( stderr, "        " );
    for( i = 0; i < TARGETS_COUNT; i++ ) {
        fprintf( stderr, "%s ", validTargets[i] );
    }
    fprintf( stderr, "\n" );
}

static void emitPrintf( unsigned depth, const char *msg, ... )
{
    va_list args;
    unsigned i;

    if( pfp != NULL ) {
        for( i = ( depth >> 1 ); i != 0; --i ) {
            fprintf( pfp, "\t" );
        }
        if( depth & 1 ) {
            fprintf( pfp, "    " );
        }
        va_start( args, msg );
        vfprintf( pfp, msg, args );
        va_end( args );
    }
}

static char *cvtOptionSpec( char *dst, const char *src, cvt_name cvt )
{
    char c;

    while( (c = *src++) != '\0' ) {
        if( c == '\\' ) {
            if( cvt == CVT_PATTERN ) {
                *dst++ = c;
            }
            c = *src++;
        } else if( cvt != CVT_USAGE ) {
            c = mytolower( c );
        }
        *dst++ = c;
    }
    *dst = '\0';
    return( dst );
}

static bool cmpOptPattern( const char *pattern1, const char *pattern2 )
{
    char    c1;
    char    c2;

    for( ;; ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
        if( c1 == '\0' ) {
            break;
        }
    }
    return( true );
}

static bool cmpChainPattern( const char *pattern1, const char *pattern2, size_t pattern_len )
{
    size_t  i;
    char    c1;
    char    c2;

    for( i = 0; i < pattern_len; i++ ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
            i++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
    }
    return( true );
}

int target_compare_qsort( const void *p1, const void *p2 )
{
    const TARGET *p1c = (const TARGET *)p1;
    const TARGET *p2c = (const TARGET *)p2;
    return( stricmp( p1c->name, p2c->name ) );
}

int target_compare_bsearch( const void *p1, const void *p2 )
{
    const char *p1c = (const char *)p1;
    const TARGET *p2c = (const TARGET *)p2;
    return( stricmp( p1c, p2c->name ) );
}

static targmask findTarget( char const *t )
{
    const TARGET *key;

    key = (const TARGET *)bsearch( t, targetList, TARGETS_COUNT, sizeof( TARGET ), target_compare_bsearch );
    if( key == NULL )
        return( 0 );
    return( key->mask );
}

static void initTargets( void )
{
    int         i;
    targmask    next_mask = 1;

    targetList = calloc( TARGETS_COUNT, sizeof( TARGET ) );
    for( i = 0; i < TARGETS_COUNT; i++ ) {
        targetList[i].name = validTargets[i];
        targetList[i].mask = next_mask;
        next_mask <<= 1;
        if( next_mask == 0 ) {
            fail( "too many targets defined\n" );
        }
    }
    qsort( targetList, TARGETS_COUNT, sizeof( TARGET ), target_compare_qsort );
}

static void finiTargets( void )
{
    free( targetList );
}

static NAME *addEnumName( NAME **h, const char *n )
{
    size_t len;
    NAME *e;

    for( e = *h; e != NULL; e = e->next ) {
        if( strcmp( n, e->name ) == 0 ) {
            return( e );
        }
    }
    len = strlen( n );
    e = malloc( sizeof( *e ) + len );
    strcpy( e->name, n );
    e->next = *h;
    *h = e;
    return( e );
}

static NAME *addEnumerator( const char *enumerate, const char *field_name )
{
    strcpy( tmpbuff, enumerate );
    strcat( tmpbuff, "_" );
    strcat( tmpbuff, field_name );
    return( addEnumName( &enumeratorList, tmpbuff ) );
}

static GROUP *findGroup( const char *pattern )
{
    GROUP *gr;

    for( gr = groupList; gr != NULL; gr = gr->next ) {
        if( strcmp( gr->pattern, pattern ) == 0 ) {
            break;
        }
    }
    return( gr );
}

static GROUP *addGroup( const char *pattern )
{
    size_t  pattern_len;
    GROUP   *gr;

    if( findGroup( pattern ) != NULL ) {
        fail( "USAGEGRP: option '%s' already defined\n", pattern );
    }
    pattern_len = strlen( pattern );
    gr = calloc( 1, sizeof( *gr ) + pattern_len );
    memcpy( gr->pattern, pattern, pattern_len + 1 );
    if( groupList == NULL ) {
        groupList = gr;
    } else {
        lastGroup->next = gr;
    }
    lastGroup = gr;
    return( gr );
}

static CHAIN *findChain( const char *pattern )
{
    CHAIN *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( cmpChainPattern( cn->pattern, pattern, cn->pattern_len ) ) {
            return( cn );
        }
    }
    return( NULL );
}

static CHAIN *addChain( char *pattern, bool chain )
{
    size_t pattern_len;
    CHAIN *cn;

    pattern_len = cvtOptionSpec( pattern, pattern, CVT_PATTERN ) - pattern;
    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( strcmp( pattern, cn->pattern ) == 0 ) {
            if( cn->code_used ) {
                fail( "CHAIN: option '%s' already defined\n", pattern );
            } else {
                fail( "USAGEOGRP: option '%s' already defined\n", pattern );
            }
        }
    }
    cn = calloc( 1, sizeof( *cn ) + pattern_len );
    cn->pattern_len = pattern_len;
    memcpy( cn->pattern, pattern, pattern_len + 1 );
    cn->name_len = cvtOptionSpec( pattern, pattern, CVT_NAME ) - pattern;
    cn->code_used = chain ? true : false;
    cn->next = chainList;
    chainList = cn;
    return( cn );
}

static FILE *initFILE( const char *fnam, const char *fmod )
{
    FILE        *fp;
    bool        open_read;

    fp = NULL;
    open_read = ( strchr( fmod, 'r' ) != NULL );
    if( open_read || fnam[0] != '.' || fnam[1] != '\0' ) {
        fp = fopen( fnam, fmod );
        if( fp == NULL ) {
            fail( "cannot open '%s' for %s", fnam, ( open_read ) ? "input" : "output" );
        }
    }
    return( fp );
}

static const char *nextWord( const char *s, char *o )
{
    while( *s != '\0' ) {
        if( myisspace( *s ) )
            break;
        *o++ = *s++;
    }
    *o = '\0';
    SKIP_SPACES( s );
    return( s );
}

static const char *nextTag( const char *s, char *o )
{
    while( *s != '\0' ) {
        if( myisspace( *s ) )
            break;
        if( *s == '.' ) {
            s++;
            break;
        }
        *o++ = *s++;
    }
    *o = '\0';
    SKIP_SPACES( s );
    return( s );
}

int tag_compare( const void *p1, const void *p2 )
{
    const char *p1c = (const char *)p1;
    const char **p2c = (const char **)p2;
    return( mystricmp( p1c, *p2c ) );
}

static tag_id findTag( char const *t )
{
    const char **key;

    key = (char const **)bsearch( t, tagNames, TAGS_COUNT, sizeof( char * ), tag_compare );
    if( key == NULL )
        return( TAG_UNKNOWN );
    return( key - tagNames );
}

static tag_id isTag( const char **eot )
{
    tag_id tag;
    const char *p;

    p = ibuff;
    SKIP_SPACES( p );
    if( *p++ == ':' ) {
        p = nextTag( p, tagbuff );
        if( (tag = findTag( tagbuff )) == TAG_UNKNOWN )
            fail( "unknown tag: %s\n", tagbuff );
        *eot = p;
        return( tag );
    }
    return( TAG_NULL );
}

static OPTION *pushNewOption( char *pattern, OPTION *o )
{
    size_t  len;
    OPTION  *newo;

    len = strlen( pattern );
    newo = calloc( 1, sizeof( *newo ) + len );
    memcpy( newo->pattern, pattern, len + 1 );
    len = cvtOptionSpec( pattern, pattern, CVT_NAME ) - pattern;
    newo->name_len = len;
    newo->name = calloc( 1, len + 1 );
    memcpy( newo->name, pattern, len + 1 );
    newo->synonym = o;
    newo->is_simple = true;
    newo->next = optionList;
    optionList = newo;
    return( newo );
}

static char *pickUpRest( const char *p )
{
    size_t  len;
    char    *dst;
    char    *out;

    // replace leading '.' character by space
    // it is used to specify spaces on the beginning of text
    // if only '.' character than it is as blank text
    // if only two '.' character than it is single space text
    len = strlen( p );
    out = dst = malloc( len + 1 );
    if( p[0] == '.' && p[1] == '\0' ) {
        len = 0;
    } else if( p[0] == '.' && p[1] == '.' && p[2] == '\0' ) {
        len = 0;
        *dst++ = ' ';
    } else {
        if( p[0] == '.' ) {
            len--;
            *dst++ = ' ';
            p++;
        }
        if( len > 0 ) {
            memcpy( dst, p, len );
        }
    }
    dst[len] = '\0';
    return( out );
}

// :argequal. <char>
static void doARGEQUAL( const char *p )
{
    if( *p == '\0' ) {
        fail( ":argequal. must have <char> specified\n" );
    } else {
        if( p[0] == '.' && p[1] == '.' ) {
            alternateEqual = ' ';
        } else {
            alternateEqual = *p;
        }
        optFlag.alternate_equal = true;
    }
}

// :cmt comment text
static void doCMT( const char *p )
{
    /* unused parameters */ (void)p;
}

// :internal.
static void doINTERNAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_internal = true;
    }
}

// :option. <option> <synonym> ...
static void doOPTION( const char *p )
{
    OPTION *synonym;

    targetTitle = NULL;
    targetFooter = NULL;
    synonym = NULL;
    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        synonym = pushNewOption( tokbuff, synonym );
    }
    getsUsage = TAG_OPTION;
}

// :target. <targ> <targ> ...
static void doTARGET( const char *p )
{
    targmask    mask;
    OPTION      *o;

    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->target_mask |= mask;
        } else if( targetFooter != NULL ) {
            targetFooter->target_mask |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->target_mask |= mask;
            }
        }
    }
}

// :ntarget. <targ> <targ> ...
static void doNTARGET( const char *p )
{
    targmask    mask;
    OPTION      *o;

    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->ntarget_mask |= mask;
        } else if( targetFooter != NULL ) {
            targetFooter->ntarget_mask |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->ntarget_mask |= mask;
            }
        }
    }
}

// :number. [<fn>] [<default>] [<usage argid>]
static void doNUMBER( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_number = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( NOSKIP( tokbuff ) ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( NOSKIP( tokbuff ) ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->number_default = atoi( tokbuff );
                o->default_specified = true;
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :multiple.
static void doMULTIPLE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_multiple = true;
    }
}

// :nochain.
static void doNOCHAIN( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->chain = NOCHAIN;
    }
}

// :id. [<fn>] [<usage argid>]
static void doID( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_id = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( NOSKIP( tokbuff ) ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :char. [<fn>] [<usage argid>]
static void doCHAR( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_char = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( NOSKIP( tokbuff ) ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :immediate. <fn> [<usage argid>]
static void doIMMEDIATE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_immediate = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->immediate_func = strdup( tokbuff );
        }
    } else {
        fail( ":immediate. must have <fn> specified\n" );
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :code. <source-code>
static void doCODE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_code = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->code = strdup( p );
        }
    } else {
        fail( ":code. must have <source-code> specified\n" );
    }
}

// :file. [<usage argid>]
static void doFILE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_file = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :optional.
static void doOPTIONAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_optional = true;
    }
}
// :negate.
static void doNEGATE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_negate = true;
        if( o->enumerate != NULL ){
            fail( "must be non-enumeration switch for negate tag\n" );
        }
    }
}


// :noequal.
static void doNOEQUAL( const char *p )
{
    /* unused parameters */ (void)p;

    optFlag.no_equal = true;
}

// :path. [<usage argid>]
static void doPATH( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_path = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :chain. <option> <usage>
//
// mark options that start with <option> as chainable
// i.e., -oa -ox == -oax
static void doCHAIN( const char *p )
{
    CHAIN *cn;

    if( *p == '\0' ) {
        fail( "missing <option> in :chain. tag\n" );
    }
    p = nextWord( p, tokbuff );
    cn = addChain( tokbuff, true );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

// :enumerate. <name> [<option>]
static void doENUMERATE( const char *p )
{
    NAME *en;
    OPTION *o;

    if( *p == '\0' ) {
        fail( "missing <name> in :enumerate. tag\n" );
    }
    p = nextWord( p, tokbuff );
    en = addEnumName( &enumList, tokbuff );
    p = nextWord( p, tokbuff );
    if( *tokbuff != '\0' ) {
        addEnumerator( en->name, tokbuff );
    }
    addEnumerator( en->name, "default" );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->enumerate = en;
        if( o->is_timestamp ) {
            o->enumerate->is_timestamp = true;
        }
        if( *tokbuff != '\0' ) {
            o->field_name = strdup( tokbuff );
        }
    }
}

// :special. <fn> [<usage argid>]
static void doSPECIAL( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_special = true;
        o->is_simple = false;
    }
    if( *p == '\0' ) {
        fail( "missing <fn> in :special. tag\n" );
    }
    p = nextWord( p, tokbuff );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->special_func = strdup( tokbuff );
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :prefix.
static void doPREFIX( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_prefix = true;
        o->is_simple = false;
    }
}

// :usage. <usage-text>
static void doUSAGE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->lang_usage[LANG_English] = pickUpRest( p );
    }
}

// :jusage. <kanji-usage-text>
static void doJUSAGE( const char *p )
{
    char *usage;
    OPTION *o;

    switch( getsUsage ) {
    case TAG_CHAIN:
        lastChain->Usage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_GROUP:
        lastGroup->Usage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_OPTION:
        for( o = optionList; o != NULL; o = o->synonym ) {
            usage = pickUpRest( p );
            if( *usage == '\0' ) {
                free( usage );
                usage = strdup( o->lang_usage[LANG_English] );
            }
            o->lang_usage[LANG_Japanese] = usage;
        }
        break;
    default:
        fail( ":jusage. must follow :chain., :group., or :option.\n" );
    }
}

// :title. <text>
static void doTITLE( const char *p )
{
    TITLE **i;
    TITLE *t;

    i = &titleList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( 1, sizeof( *t ) );
    t->next = *i;
    *i = t;
    t->lang_title[LANG_English] = pickUpRest( p );
    targetTitle = t;
    targetFooter = NULL;
}

// :titleu. <text>
static void doTITLEU( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":titleu. must follow a :title.\n" );
    }
    t->lang_titleu[LANG_English] = pickUpRest( p );
    t->is_titleu = true;
}

// :jtitle. <text>
static void doJTITLE( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":jtitle. must follow a :title.\n" );
    }
    t->lang_title[LANG_Japanese] = pickUpRest( p );
}

// :jtitleu. <text>
static void doJTITLEU( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":jtitleu. must follow a :title.\n" );
    }
    t->lang_titleu[LANG_Japanese] = pickUpRest( p );
    t->is_titleu = true;
}

// :footer. <text>
static void doFOOTER( const char *p )
{
    TITLE **i;
    TITLE *t;

    i = &footerList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( 1, sizeof( *t ) );
    t->next = *i;
    *i = t;
    t->lang_title[LANG_English] = pickUpRest( p );
    targetFooter = t;
    targetTitle = NULL;
}

// :footeru. <text>
static void doFOOTERU( const char *p )
{
    TITLE *t;

    t = targetFooter;
    if( t == NULL ) {
        fail( ":footeru. must follow a :footer.\n" );
    }
    t->lang_titleu[LANG_English] = pickUpRest( p );
    t->is_titleu = true;
}

// :jfooter. <text>
static void doJFOOTER( const char *p )
{
    TITLE *t;

    t = targetFooter;
    if( t == NULL ) {
        fail( ":jfooter. must follow a :footer.\n" );
    }
    t->lang_title[LANG_Japanese] = pickUpRest( p );
}

// :jfooteru. <text>
static void doJFOOTERU( const char *p )
{
    TITLE *t;

    t = targetFooter;
    if( t == NULL ) {
        fail( ":jfooteru. must follow a :footer.\n" );
    }
    t->lang_titleu[LANG_Japanese] = pickUpRest( p );
    t->is_titleu = true;
}

// :group. <num>
static void doGROUP( const char *p )
{
    OPTION *o;
    GROUP  *gr;

    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        gr = findGroup( tokbuff );
        if( gr != NULL ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                 o->group = gr;
            }
        }
    }
}


// :timestamp.
static void doTIMESTAMP( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_timestamp = true;
        o->is_simple = false;
        if( o->enumerate != NULL ) {
            o->enumerate->is_timestamp = true;
        }
    }
}

// :usageogrp. <option> <usage>
//
// mark options that start with <option> as group in usage text
// i.e., -fp0 -fp1 ==> -fp{0,1}
static void doUSAGEOGRP( const char *p )
{
    CHAIN *cn;

    if( *p == '\0' ) {
        fail( "missing <option> in :usageogrp. tag\n" );
    }
    p = nextWord( p, tokbuff );
    cn = addChain( tokbuff, false );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

// :usagegrp. <num> <usage text>
//
// define group <num> with usage text for block of options
//
static void doUSAGEGRP( const char *p )
{
    GROUP *gr;

    if( *p == '\0' ) {
        fail( "missing <num> in :usagegrp. tag\n" );
    }
    p = nextWord( p, tokbuff );
    gr = addGroup( tokbuff );
    gr->Usage[LANG_English] = pickUpRest( p );
    lastGroup = gr;
    getsUsage = TAG_GROUP;
}

static void checkForGMLEscape( const char *p )
{
    bool is_escape;
    char c1, c2;

    c1 = *p++;
    if( c1 == '\0' || ! isalpha( c1 ) ) {
        return;
    }
    c2 = *p++;
    if( c2 == '\0' || ! isalpha( c2 ) ) {
        return;
    }
    is_escape = false;
    if( *p == '\0' || ! isalpha( *p ) ) {
        is_escape = true;
    }
    if( is_escape ) {
        fail( "possible GML escape sequence: &%c%c\n", c1, c2 );
    }
}

static void checkForGMLEscapeSequences( void )
{
    char c;
    char *p;

    for( p = ibuff; (c = *p++) != '\0'; ) {
        if( c == '&' ) {
            checkForGMLEscape( p );
        }
    }
}

static char *my_fgets( char *buff, int buff_len, FILE *fp )
{
    char    *p;
    size_t  len;

    p = fgets( buff, buff_len, fp );
    if( p != NULL ) {
        for( len = strlen( p ); len > 0 && ( p[len - 1] == '\n' || p[len - 1] == '\r' ); len-- )
            ;
        p[len] = '\0';
    }
    return( p );
}

static void readInputFile( void )
{
    const char  *eot;
    tag_id      tag;

    for( ; my_fgets( ibuff, sizeof( ibuff ), gfp ) != NULL; ) {
        ++line;
        checkForGMLEscapeSequences();
        tag = isTag( &eot );
        if( tag != TAG_NULL ) {
            (*processTag[tag])( eot );
        }
    }
}

static void checkForMissingUsages( void )
{
    OPTION *o;
    int start_lang;
    int end_lang;
    int i;

    if( optFlag.international ) {
        start_lang = 0;
        end_lang = LANG_MAX;
    } else {
        start_lang = LANG_English;
        end_lang = start_lang + 1;
    }
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NULL || cmpOptPattern( o->pattern, o->chain->pattern ) ) {
            for( i = start_lang; i < end_lang; ++i ) {
                if( o->lang_usage[i] == NULL ) {
                    fail( "option '%s' has no %s usage\n", o->pattern, langName[i] );
                }
            }
        }
    }
}

static void assignChainToOptions( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NOCHAIN ) {
            o->chain = NULL;
        } else {
            o->chain = findChain( o->pattern );
        }
    }
}

static void stripUselessOptions( void )
{
    OPTION **h;
    OPTION *o;
    OPTION *o_next;

    h = &optionList;
    for( o = *h; o != NULL; o = o_next ) {
        o_next = o->next;
        if( IS_SELECTED( o ) ) {
            h = &(o->next);
        } else {
            o->next = uselessOptionList;
            uselessOptionList = o;
            *h = o_next;
        }
    }
}

static char *strpcpy( char *d, const char *s )
{
    size_t len;

    len = strlen( s );
    strcpy( d, s );
    return( d + len );
}

static char *special_char( char *f, char c )
{
    if( c == '~' ) {
        f = strpcpy( f, "_tilde" );
    } else if( c == '+' ) {
        f = strpcpy( f, "_plus" );
    } else if( c == '!' ) {
        f = strpcpy( f, "_exclamation" );
    } else if( c == '#' ) {
        f = strpcpy( f, "_sharp" );
    } else {
        *f++ = '_';
    }
    return( f );
}

static void makeFieldName( const char *pattern, char *f )
{
    char c;
    bool sensitive;
    bool is_special;

    c = *pattern++;
    if( c == '\\' ) {
        c = *pattern++;
    } else {
        c = mytolower( c );
    }
    if( c != '\0' ) {
        is_special = false;
        if( isalnum( c ) ) {
            if( isdigit( c ) )
                *f++ = '_';
            *f++ = c;
        } else {
            f = special_char( f, c );
            is_special = true;
        }
        sensitive = false;
        for( ; (c = *pattern++) != '\0'; ) {
            if( c == '\\' ) {
                sensitive = true;
                continue;
            }
            if( isalnum( c ) ) {
                if( is_special && *( f - 1 ) != '_' )
                    *f++ = '_';
                if( !sensitive )
                    c = mytolower( c );
                *f++ = c;
                is_special = false;
            } else {
                f = special_char( f, c );
                is_special = true;
            }
            sensitive = false;
        }
    }
    *f = '\0';
}

static void initOptionFields( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( o->field_name == NULL ) {
                makeFieldName( o->pattern, tokbuff );
                o->field_name = strdup( tokbuff );
            }
            if( o->value_field_name == NULL ) {
                strcpy( tokbuff, o->field_name );
                strcat( tokbuff, "_value" );
                o->value_field_name = strdup( tokbuff );
            }
        }
    }
}

static void startParserH( void )
{
    OPTION *o;
    NAME *en;

    if( ofp != NULL ) {
        fprintf( ofp, "typedef struct opt_string OPT_STRING;\n" );
        fprintf( ofp, "struct opt_string {\n" );
        fprintf( ofp, "    OPT_STRING *next;\n" );
        fprintf( ofp, "    char data[1];\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_number OPT_NUMBER;\n" );
        fprintf( ofp, "struct opt_number {\n" );
        fprintf( ofp, "    OPT_NUMBER *next;\n" );
        fprintf( ofp, "    unsigned number;\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_storage OPT_STORAGE;\n" );
        fprintf( ofp, "struct opt_storage {\n" );
        fprintf( ofp, "    unsigned     timestamp;\n" );
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                if( o->is_number ) {
                    if( HAS_OPT_NUMBER( o ) ) {
                        fprintf( ofp, "    OPT_NUMBER   *%s;\n", o->value_field_name );
                    } else {
                        fprintf( ofp, "    unsigned     %s;\n", o->value_field_name );
                    }
                } else if( o->is_char ) {
                    fprintf( ofp, "    int          %s;\n", o->value_field_name );
                } else if( HAS_OPT_STRING( o ) ) {
                    fprintf( ofp, "    OPT_STRING   *%s;\n", o->value_field_name );
                }
                if( o->is_timestamp ) {
                    if( o->enumerate == NULL ) {
                        fprintf( ofp, "    unsigned     %s_timestamp;\n", o->field_name );
                    }
                }
            }
        }
        for( en = enumList; en != NULL; en = en->next ) {
            fprintf( ofp, "    unsigned     %s;\n", en->name );
            if( en->is_timestamp ) {
                fprintf( ofp, "    unsigned     %s_timestamp;\n", en->name );
            }
        }
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                if( o->enumerate == NULL ) {
                    fprintf( ofp, "    boolbit      %s : 1;\n", o->field_name );
                }
            }
        }
        fprintf( ofp, "};\n" );
    }
}

static void finishParserH( void )
{
    NAME *en;
    unsigned value;

    if( ofp != NULL ) {
        value = 0;
        for( en = enumeratorList; en != NULL; en = en->next ) {
            ++value;
            fprintf( ofp, "#define OPT_ENUM_%s %u\n", en->name, value );
        }
    }
}

static CODESEQ *newCode( OPTION *o, char c, bool sensitive )
{
    CODESEQ *p;

    p = calloc( 1, sizeof( *p ) );
    p->option = o;
    p->c = c;
    p->sensitive = sensitive ? true : false;
    return( p );
}

static CODESEQ *addOptionCodeSeq( CODESEQ *code, OPTION *o )
{
    bool    sensitive;
    char    *pattern;
    char    c;
    CODESEQ *head;
    CODESEQ **splice;

    head = code;
    splice = &head;
    for( pattern = o->pattern; (c = *pattern++) != '\0'; ) {
        sensitive = false;
        if( c == '\\' ) {
            c = *pattern++;
            sensitive = true;
        } else {
            c = mytolower( c );
        }
        for( code = *splice; code != NULL; code = *splice ) {
            if( code->sensitive == sensitive ) {
                if( code->c == c ) {
                    break;
                }
            }
            splice = &(code->sibling);
        }
        if( code == NULL ) {
            code = newCode( o, c, sensitive );
            *splice = code;
        }
        splice = &(code->children);
    }
    if( code == NULL ) {
        code = newCode( o, '\0', false );
        *splice = code;
    }
    code->accept = true;
    code->option = o;
    return( head );
}

static CODESEQ *reorderCode( CODESEQ *c )
{
    CODESEQ *a;
    CODESEQ *h;
    CODESEQ *n;
    CODESEQ **s;

    h = c;
    if( c->sibling != NULL ) {
        a = NULL;
        s = &h;
        // accepting states move to the end
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->accept ) {
                *s = n;
                c->sibling = a;
                a = c;
            } else {
                s = &(c->sibling);
            }
        }
        *s = a;
        s = &(h->sibling);
        // sensitive states move to the front
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->sensitive ) {
                *s = n;
                c->sibling = h;
                h = c;
            } else {
                s = &(c->sibling);
            }
        }
    }
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->children != NULL ) {
            c->children = reorderCode( c->children );
        }
    }
    return( h );
}

static bool markChainCode( CODESEQ *h, size_t level )
{
    CODESEQ *c;
    bool    rc;

    rc = false;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            if( c->children != NULL ) {
                if( level == c->option->chain->name_len ) {
                    if( markChainCode( c->children, level + 1 ) ) {
                        c->chain_root = true;
                    }
                }
            } else if( c->option->name_len == c->option->chain->name_len + 1 ) {
                c->chain = true;
                rc = true;
            }
        }
    }
    return( rc );
}

static CODESEQ *genCode( OPTION *o )
{
    CODESEQ *head;

    head = NULL;
    for( ; o != NULL; o = o->next ) {
        head = addOptionCodeSeq( head, o );
    }
    head = reorderCode( head );
    markChainCode( head, 1 );
    return( head );
}

static bool useSwitchStmt( CODESEQ *h )
{
    unsigned count;
    CODESEQ *c;

    count = 0;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->is_prefix ) {
            return( true );
        }
        ++count;
    }
    return( count >= USE_SWITCH_THRESHOLD );
}

static void emitSuccessCode( unsigned depth, flow_control control )
{
    if( control & EC_CONTINUE ) {
        emitPrintf( depth, "continue;\n" );
    } else {
        emitPrintf( depth, "return( false );\n" );
    }
}

static void emitAcceptCode( CODESEQ *c, unsigned depth, flow_control control )
{
    NAME *ei;
    OPTION *o;
    struct {
        boolbit     close_value_if : 1;
    } flag;

    o = c->option;
    while( o->synonym != NULL ) {
        o = o->synonym;
    }
    if( o->is_prefix ) {
        emitPrintf( depth, "if( " FN_END "() ) {\n" );
        ++depth;
    }
    flag.close_value_if = false;
    if( o->is_number ) {
        if( o->default_specified ) {
            emitPrintf( depth, "if( " FN_NUMBER_DEFAULT "( &(data->%s ), %u ) ) {\n", o->value_field_name, o->number_default );
        } else if( o->is_multiple ) {
            emitPrintf( depth, "if( " FN_NUMBER_MULTIPLE "( &(data->%s ) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_NUMBER "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_char ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_CHAR_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_CHAR "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_id ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_ID_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_ID "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_file ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_FILE_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_FILE "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_path ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_PATH_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_PATH "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_special ) {
        emitPrintf( depth, "if( %s( &(data->%s) ) ) {\n", o->special_func, o->value_field_name );
        ++depth;
        flag.close_value_if = true;
    }
    if( o->check_func != NULL ) {
        emitPrintf( depth, "%s( &(data->%s) );\n", o->check_func, o->value_field_name );
    }
    if( o->enumerate != NULL ) {
        ei = addEnumerator( o->enumerate->name, o->field_name );
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->enumerate->name );
        }
        emitPrintf( depth, "data->%s = OPT_ENUM_%s;\n", o->enumerate->name, ei->name );
        if( o->is_immediate ) {
            emitPrintf( depth, "%s( data, true );\n", o->immediate_func );
        }
    } else {
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->field_name );
        }
        if( o->is_negate ) {
            emitPrintf( depth, "if( %s( '-' ) ) {\n", FN_RECOG );
            emitPrintf( depth+1, "data->%s = false;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, false );\n", o->immediate_func );
            }
            emitPrintf( depth, "} else {\n" );
            emitPrintf( depth+1, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, true );\n", o->immediate_func );
            }
            emitPrintf( depth, "}\n" );
        } else {
            emitPrintf( depth, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth, "%s( data, true );\n", o->immediate_func );
            }
        }
    }
    if( o->is_code ) {
        emitPrintf( depth, "%s;\n", o->code );
    }
    if( flag.close_value_if ) {
        --depth;
        emitPrintf( depth, "}\n" );
    }
    emitSuccessCode( depth, control );
    if( o->is_prefix ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, "break;\n" );
    }
}

static void emitCodeTree( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->children ) {
        if( c->chain ) {
            emitCode( c->children, depth, (control & ~EC_CHAIN) | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        } else if( c->chain_root ) {
            emitCode( c->children, depth, control | EC_CHAIN | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitSuccessCode( depth, control );
            }
        } else {
            emitCode( c->children, depth, control & ~EC_CHAIN );
            if( c->accept ) {
                emitAcceptCode( c, depth, control );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        }
    } else {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            emitAcceptCode( c, depth, control );
        } else {
            emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
        }
    }
}

static void emitIfCode( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->sensitive ) {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG, c->c );
    } else {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG_LOWER, c->c );
    }
    emitCodeTree( c, depth + 1, control );
    emitPrintf( depth, "}\n" );
}

static void emitCode( CODESEQ *h, unsigned depth, flow_control control )
{
    bool use_switch;
    CODESEQ *c;

    for( c = h; c != NULL; c = c->sibling ) {
        if( c->sensitive || (control & EC_CHAIN) && !c->chain ) {
            emitIfCode( c, depth, control );
        } else {
            break;
        }
    }
    if( c == NULL ) {
        return;
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "do {\n" );
        ++depth;
    }
    use_switch = useSwitchStmt( c );
    if( use_switch ) {
        emitPrintf( depth, "switch( " FN_GET_LOWER "() ) {\n" );
        ++depth;
    }
    for( ; c != NULL; c = c->sibling ) {
        if( use_switch ) {
            emitPrintf( depth - 1, "case '%c':\n", c->c );
            emitCodeTree( c, depth, control );
        } else {
            emitIfCode( c, depth, control );
        }
    }
    if( use_switch ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, FN_UNGET "();\n" );
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "break;\n" );
        --depth;
        emitPrintf( depth, "} while( ! " FN_END "() );\n" );
    }
}

static void outputFN_PROCESS( void )
{
    unsigned depth = 0;
    CODESEQ *codeseq;

    emitPrintf( depth, "bool " FN_PROCESS "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    codeseq = genCode( optionList );
    emitCode( codeseq, depth, EC_NULL );
    emitPrintf( depth, "return( true );\n" );
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_INIT( void )
{
    OPTION *o;
    NAME *en;
    NAME *ei;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_INIT "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    emitPrintf( depth, "memset( data, 0, sizeof( *data ) );\n" );
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL && o->is_number && o->default_specified ) {
            emitPrintf( depth, "data->%s = %u;\n", o->value_field_name, o->number_default );
        }
    }
    for( en = enumList; en != NULL; en = en->next ) {
        ei = addEnumerator( en->name, "default" );
        emitPrintf( depth, "data->%s = OPT_ENUM_%s;\n", en->name, ei->name );
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_FINI( void )
{
    OPTION *o;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_FINI "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( HAS_OPT_STRING( o ) ) {
                emitPrintf( depth, FN_CLEAN_STRING "( &(data->%s) );\n", o->value_field_name );
            } else if( HAS_OPT_NUMBER( o ) ) {
                emitPrintf( depth, FN_CLEAN_NUMBER "( &(data->%s) );\n", o->value_field_name );
            }
        }
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static int usageCmp( const void *v1, const void *v2 )
{
    int     res;
    size_t  name_len;
    OPTION  *o1 = *(OPTION **)v1;
    OPTION  *o2 = *(OPTION **)v2;
    char    *n1 = o1->name;
    char    *n2 = o2->name;

    res = 0;
    if( o1->chain != o2->chain ) {
        if( o1->chain == NULL ) {
            name_len = o2->chain->name_len;
        } else if( o2->chain == NULL ) {
            name_len = o1->chain->name_len;
        } else if( o1->chain->name_len > o2->chain->name_len ) {
            name_len = o1->chain->name_len;
        } else {
            name_len = o2->chain->name_len;
        }
        res = strnicmp( n1, n2, name_len );
        if( res == 0 ) {
            res = strncmp( n1, n2, name_len );
            if( res == 0 ) {
                if( o1->chain == NULL ) {
                    return( 1 );
                }
                if( o2->chain == NULL ) {
                    return( -1 );
                }
                n1 += name_len;
                n2 += name_len;
            }
        }
    }
    if( res == 0 ) {
        res = mystricmp( n1, n2 );
        if( res == 0 ) {
            return( strcmp( n1, n2 ) );
        }
    }
    if( res < 0 ) {
        return( -1 );
    } else {
        return( 1 );
    }
}

static char *catArg( char *arg, char *buf )
{
    for( ; *arg != '\0'; ++arg ) {
        if( optFlag.no_equal ) {
            if( *arg != '=' ) {
                *buf++ = *arg;
            }
        } else if( optFlag.alternate_equal ) {
            if( *arg != '=' ) {
                *buf++ = *arg;
            } else {
                *buf++ = alternateEqual;
            }
        } else {
            *buf++ = *arg;
        }
    }
    *buf = '\0';
    return( buf );
}

static char *genOptionUsageStart( OPTION *o, char *buf, bool no_prefix )
{
    if( o->chain != NULL ) {
        if( !no_prefix ) {
            *buf++ = ' ';
            *buf++ = ' ';
        }
        strcpy( buf, o->name + o->chain->name_len );
        buf += strlen( buf );
    } else {
        *buf++ = '-';
        buf = cvtOptionSpec( buf, o->pattern, CVT_USAGE );
    }
    if( o->usage_argid != NULL ) {
        if( o->is_optional ) {
            buf = catArg( "[=", buf );
            buf = catArg( o->usage_argid, buf );
            buf = catArg( "]", buf );
        } else {
            buf = catArg( "=", buf );
            buf = catArg( o->usage_argid, buf );
        }
    } else if( o->is_number ) {
        if( o->default_specified || o->is_optional ) {
            buf = catArg( "[=<num>]", buf );
        } else {
            buf = catArg( "=<num>", buf );
        }
    } else if( o->is_char ) {
        if( o->is_optional ) {
            buf = catArg( "[=<char>]", buf );
        } else {
            buf = catArg( "=<char>", buf );
        }
    } else if( o->is_id ) {
        if( o->is_optional ) {
            buf = catArg( "[=<id>]", buf );
        } else {
            buf = catArg( "=<id>", buf );
        }
    } else if( o->is_file ) {
        if( o->is_optional ) {
            buf = catArg( "[=<file>]", buf );
        } else {
            buf = catArg( "=<file>", buf );
        }
    } else if( o->is_path ) {
        if( o->is_optional ) {
            buf = catArg( "[=<path>]", buf );
        } else {
            buf = catArg( "=<path>", buf );
        }
    } else if( o->is_negate ) {
        buf = catArg( "[-]", buf );
    } else if( o->is_special ) {
    }
    return( buf );
}

static bool usageValid( OPTION *o, GROUP *gr )
{
    if( o->group != gr )
        return( false );
    if( o->synonym != NULL )
        return( false );
    if( o->is_internal && (targetMask & targetDbgMask) == 0 )
        return( false );
    return( true );
}

static void emitQuotedString( FILE *fp, const char *str, bool zero_term, bool comma_list )
{
    size_t      len;
    const char  *q;
    const char  *s;

    fprintf( fp, "\"" );
    for( s = str; (q = strchr( s, '"' )) != NULL; s = q + 1 ) {
        // replace " with \"
        len = q - s;
        memcpy( tmpbuff, s, len );
        tmpbuff[len] = '\0';
        fprintf( fp, "%s\\\"", tmpbuff );
    }
    fprintf( fp, "%s%s\"%s", s, ( zero_term ) ? "\\0" : "", ( comma_list ) ? "," : "" );
}

static void emitUsageH( void )
{
    static int  line_offs = 0;
    size_t      len;
    const char  *str;

    if( optFlag.rc ) {
        if( ufp != NULL ) {
            fprintf( ufp, "pick((%s+%d), ", optFlag.rc_macro, line_offs++ );
            emitQuotedString( ufp, getLangData( outputdata, LANG_English ), false, false );
            fprintf( ufp, ", " );
            str = getLangData( outputdata, LANG_Japanese );
            if( !optFlag.out_utf8 ) {
                utf8_to_cp932( str, tmpbuff );
                str = tmpbuff;
            }
            emitQuotedString( ufp, str, false, false );
            fprintf( ufp, ")\n" );
        }
    } else {
        str = getLangData( outputdata, optFlag.lang );
        len = strlen( str );
        if( maxUsageLen < len ) {
            maxUsageLen = len;
            strcpy( maxusgbuff, str );
        }
        if( ufp != NULL ) {
            emitQuotedString( ufp, str, ( optFlag.zero_term ) ? true : false, ( optFlag.comma_list ) ? true : false );
            fprintf( ufp, "\n" );
        }
    }

}

static void emitUsageHQNX( void )
{
    const char *str;

    if( mfp != NULL ) {
        str = getLangData( outputdata, optFlag.lang );
        fprintf( mfp, "%s\n", str );
    }

}

static void process_output( process_line_fn *process_line )
{
    process_line();
    if( process_line == emitUsageH ) {
        emitUsageHQNX();
    }
}

static void expand_tab( const char *s, char *buf )
{
    int len;

    for( ; *s != '\0'; ++s ) {
        if( s[0] == '\\' && s[1] == 't' ) {
            ++s;
            for( len = 8; len-- > 0; ) {
                *buf++ = ' ';
            }
        } else {
            *buf++ = *s;
        }
    }
    *buf = '\0';
}

#define HEADER_LEFT_MARGIN   8

static void procBlockHeader( lang_data langdata, language_id lang )
{
    const char  *s;
    size_t      len;
    char        *buf;

    buf = GET_OUTPUT_BUF( lang );
    s = getLangData( langdata, lang );
    len = strlen( s );
    if( len < 80 ) {
        len = ( 80 - len ) / 2;
        if( len > HEADER_LEFT_MARGIN )
            len = HEADER_LEFT_MARGIN;
        while( len-- > 0 ) {
            *buf++ = ' ';
        }
    }
    strcpy( buf, s );
}

static void outputBlockHeader( lang_data langdata, process_line_fn *process_line )
{
    language_id lang;

    for( lang = 0; lang < LANG_MAX; lang++ ) {
        procBlockHeader( langdata, lang );
    }
    process_output( process_line );
}

static void outputTitle( lang_data langdata, process_line_fn *process_line )
{
    language_id lang;

    for( lang = 0; lang < LANG_MAX; lang++ ) {
        expand_tab( getLangData( langdata, lang ), GET_OUTPUT_BUF( lang ) );
    }
    process_line();
}

static void outputUsageHeader( process_line_fn *process_line )
{
    TITLE       *t;

    for( t = titleList; t != NULL; t = t->next ) {
        if( IS_SELECTED( t ) ) {
            outputTitle( t->lang_title, process_line );
            if( process_line == emitUsageH ) {
                outputTitle( ( t->is_titleu ) ? t->lang_titleu : t->lang_title, emitUsageHQNX );
            }
        }
    }
}

static void outputUsageFooter( process_line_fn *process_line )
{
    TITLE       *t;

    for( t = footerList; t != NULL; t = t->next ) {
        if( IS_SELECTED( t ) ) {
            outputTitle( t->lang_title, process_line );
            if( process_line == emitUsageH ) {
                outputTitle( ( t->is_titleu ) ? t->lang_titleu : t->lang_title, emitUsageHQNX );
            }
        }
    }
}

static void clearChainUsage( void )
{
    CHAIN   *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        cn->usage_used = false;
    }
}

static bool createChainHeaderPrefix( OPTION **t, char *buf, size_t max )
{
    size_t      len;
    CHAIN       *cn;
    char        *stop;

    stop = buf + max;
    cn = (*t)->chain;
    *buf++ = '-';
    buf = cvtOptionSpec( buf, cn->pattern, CVT_NAME );
    *buf++ = '{';
    len = 0;
    for( ; *t != NULL && (*t)->chain == cn; t++ ) {
        if( (*t)->chain != NULL ) {
            if( len > 0 ) {
                *buf++ = ',';
            }
            buf = genOptionUsageStart( *t, buf, true );
            ++len;
        }
    }
    *buf++ = '}';
    *buf++ = ' ';
    while( buf < stop )
        *buf++ = ' ';
    *buf = '\0';
    return( buf == stop );
}

static void outputChainHeader( OPTION **t, process_line_fn *process_line, size_t max )
{
    char        *buf;
    size_t      len;
    language_id lang;

    if( createChainHeaderPrefix( t, hdrbuff, max ) ) {
        for( lang = 0; lang < LANG_MAX; lang++ ) {
            buf = GET_OUTPUT_BUF( lang );
            strcpy( buf, hdrbuff );
            strcpy( buf + max, getLangData( (*t)->chain->Usage, lang ) );
        }
    } else {
        for( lang = 0; lang < LANG_MAX; lang++ ) {
            buf = GET_OUTPUT_BUF( lang );
            for( len = max / 2; len-- > 0; )
                *buf++ = ' ';
            strcpy( buf, getLangData( (*t)->chain->Usage, lang ) );
        }
        process_output( process_line );
        for( lang = 0; lang < LANG_MAX; lang++ ) {
            strcpy( GET_OUTPUT_BUF( lang ), hdrbuff );
        }
    }
    process_output( process_line );
}

static char *createOptionPrefix( OPTION *o, char *buf, size_t max )
{
    char    *stop;

    stop = buf + max;
    buf = genOptionUsageStart( o, buf, false );
    while( buf < stop )
        *buf++ = ' ';
    if( o->chain != NULL ) {
        *buf++ = '-';
        *buf++ = ' ';
    }
    *buf = '\0';
    return( buf );
}

static void outputOption( OPTION *o, process_line_fn *process_line, size_t max )
{
    char        *buf;
    size_t      len;
    language_id lang;

    len = createOptionPrefix( o, hdrbuff, max ) - hdrbuff;
    for( lang = 0; lang < LANG_MAX; lang++ ) {
        buf = GET_OUTPUT_BUF( lang );
        strcpy( buf, hdrbuff );
        strcpy( buf + len, getLangData( o->lang_usage, lang ) );
    }
    process_output( process_line );
}

static bool checkUsageLength( size_t len )
{
    return( ( len / langMaxChar[optFlag.lang] ) > CONSOLE_WIDTH );
}

static void processUsage( process_line_fn *process_line, GROUP *gr )
{
    unsigned    count;
    unsigned    i;
    size_t      max;
    size_t      len;
    OPTION      *o;
    OPTION      **t;
    OPTION      **c;

    maxUsageLen = 0;
    max = 0;
    count = 0;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, gr ) ) {
            ++count;
            len = genOptionUsageStart( o, tmpbuff, false ) - tmpbuff;
            if( max < len ) {
                max = len;
            }
        }
    }
    ++max;
    t = calloc( count + 1, sizeof( OPTION * ) );
    c = t;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, gr ) ) {
            *c++ = o;
        }
    }
    *c = NULL;
    qsort( t, count, sizeof( OPTION * ), usageCmp );

    clearChainUsage();
    for( i = 0; i < count; ++i ) {
        if( t[i]->chain != NULL && !t[i]->chain->usage_used ) {
            t[i]->chain->usage_used = true;
            outputChainHeader( &t[i], process_line, max );
        }
        outputOption( t[i], process_line, max );
    }
    free( t );
    if( checkUsageLength( maxUsageLen ) ) {
        fprintf( stderr, "usage message exceeds %u chars\n%s\n", CONSOLE_WIDTH, maxusgbuff );
    }
}

static bool checkGroupUsed( GROUP *gr )
{
    OPTION  *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, gr ) ) {
            return( true );
        }
    }
    return( false );
}

static void outputUsage( process_line_fn *process_line )
{
    GROUP       *gr;

    outputUsageHeader( process_line );

    gr = NULL;
    processUsage( process_line, gr );
    for( gr = groupList; gr != NULL; gr = gr->next ) {
        if( checkGroupUsed( gr ) ) {
            outputBlockHeader( gr->Usage, process_line );
            processUsage( process_line, gr );
        }
    }

    outputUsageFooter( process_line );
}

static void outputUsageH( void )
{
    outputUsage( emitUsageH );
}

static void emitUsageB( void )
{
    size_t len;
    const char *str;

    str = getLangData( outputdata, optFlag.lang );
    if( optFlag.lang == LANG_Japanese ) {
        if( !optFlag.out_utf8 ) {
            utf8_to_cp932( str, tmpbuff );
            str = tmpbuff;
        }
    }
    len = strlen( str ) + 1;
    fwrite( str, len, 1, bfp );
    if( maxUsageLen < len ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, str );
    }
}

static void dumpInternational( void )
{
    char        fname[16];
    LocaleUsage usage_header;

    if( optFlag.international ) {
        for( optFlag.lang = LANG_FIRST_INTERNATIONAL; optFlag.lang < LANG_MAX; optFlag.lang++ ) {
            sprintf( fname, "usage%02u." LOCALE_DATA_EXT, optFlag.lang );
            bfp = fopen( fname, "wb" );
            if( bfp == NULL ) {
                fail( "cannot open international file for write\n" );
            }
            memset( &usage_header, 0, sizeof( usage_header ) );
            usage_header.header.code = LS_Usage;
            usage_header.header.signature = LS_Usage_SIG;
            fwrite( &usage_header, offsetof( LocaleUsage, data ), 1, bfp );

            outputUsage( emitUsageB );

            fputc( 0, bfp );
            fclose( bfp );
            bfp = NULL;
        }
    }
}

static void closeFiles( void )
{
    fclose( gfp );
    if( mfp != NULL )
        fclose( mfp );
    if( ofp != NULL )
        fclose( ofp );
    if( pfp != NULL )
        fclose( pfp );
    if( ufp != NULL ) {
        fclose( ufp );
    }
}

static void initUTF8( void )
{
    if( !optFlag.out_utf8 ) {
        qsort( cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
    }
}

static char *ReadIndirectFile( char *name )
/*****************************************/
{
    char        *str;
    FILE        *fp;
    int         len;
    char        ch;

    str = NULL;
    fp = fopen( name, "rb" );
    if( fp != NULL ) {
        fseek( fp, 0, SEEK_END );
        len = ftell( fp );
        fseek( fp, 0, SEEK_SET );
        str = malloc( len + 1 );
        fread( str, 1, len, fp );
        str[len] = '\0';
        fclose( fp );
        // go through characters changing \r, \n etc into ' '
        for( ; (ch = *str) != '\0'; str++ ) {
            if( ch == 0x1A ) {      // if end of file
                *str = '\0';        // - mark end of str
                break;
            }
            if( ch != ' ' && myisspace( ch ) ) {
                *str = ' ';
            }
        }
    }
    return( str );
}

static char *getFileName( char *str, char *name )
/***********************************************/
{
    char        ch;

    SKIP_SPACES( str );
    if( *str == '\"' ) {
        str++;
        while( (ch = *str) != '\0' ) {
            str++;
            if( ch == '"' ) {
                break;
            }
            if( ch == '\\' && *str == '"' ) {
                ch = *str++;
            }
            *name++ = ch;
        }
    } else {
        while( *str != '\0' && !myisspace( *str ) ) {
            *name++ = *str++;
        }
    }
    *name = '\0';
    return( str );
}

static char *ProcessOption( char *s, char *option_start )
/*******************************************************/
{
    switch( *s++ ) {
    case 'c':
        optFlag.comma_list = true;
        return( s );
    case 'i':
        optFlag.international = true;
        return( s );
    case 'l':
        if( *s++ == '=' ) {
            optFlag.lang = strtol( s, &s, 10 );
            return( s );
        }
        break;
    case 'n':
        optFlag.zero_term = true;
        return( s );
    case 'q':
        optFlag.quiet = true;
        return( s );
    case 'r':
        if( *s++ == 'c' && *s++ == '=' ) {
            optFlag.rc = true;
            SKIP_SPACES( s );
            optFlag.rc_macro = option_start;
            while( *s != '\0' ) {
                if( myisspace( *s ) ) {
                    s++;
                    break;
                }
                *option_start++ = *s++;
            }
            *option_start = '\0';
            return( s );
        }
        break;
    case 'u':
        if( *s == '=' ) {
            s = getFileName( s + 1, option_start );
            mfp = fopen( option_start, "wb" );
            if( mfp == NULL ) {
                fail( "cannot open '%s' for output", option_start );
            }
            return( s );
        } else if( *s++ == 't' && *s++ == 'f' && *s++ == '8' ) {
            optFlag.out_utf8 = true;
            return( s );
        }
        break;
    }
    printf( "Unknown option: %s\n", option_start );
    return( NULL );
}

static bool ProcessOptions( char *str )
/*************************************/
{
    char        name[PATH_MAX];
    char        *fstr;
    bool        rc;
    char        *p;
    targmask    mask;

    rc = 0;
    fstr = NULL;
    name[0] = '\0';
    while( *str != '\0' ) {
        SKIP_SPACES( str );
        if( *str == '@' ) {
            str = getFileName( str + 1, name );
            str = getenv( name );
            if( str == NULL ) {
                str = fstr = ReadIndirectFile( name );
            }
        }
        if( *str == '\0' ) {
            continue;
        }
        if( *str == '-' ) {
            str = ProcessOption( str + 1, str );
            if( str == NULL ) {
                rc = true;
                break;
            }
        } else {  /* collect file name */
            switch( fno++ ) {
            case 0:
                str = getFileName( str, name );
                gfp = initFILE( name, "r" );
                break;
            case 1:
                str = getFileName( str, name );
                ofp = initFILE( name, "w+" );
                break;
            case 2:
                str = getFileName( str, name );
                pfp = initFILE( name, "w+" );
                break;
            case 3:
                str = getFileName( str, name );
                ufp = initFILE( name, "w+" );
                p = "any";
                if( (targetAnyMask = findTarget( p )) == 0 ) {
                    fail( "invalid target name '%s'\n", p );
                }
                p = "dbg";
                if( (targetDbgMask = findTarget( p )) == 0 ) {
                    fail( "invalid target name '%s'\n", p );
                }
                targetMask |= targetAnyMask;
                break;
            default:
                p = name;
                while( *str != '\0' ) {
                    if( myisspace( *str ) )
                        break;
                    *p++ = *str++;
                }
                *p = '\0';
                if( *name != '\0' ) {
                    if( (mask = findTarget( name )) == 0 ) {
                        fail( "invalid target name '%s'\n", name );
                    }
                    targetMask |= mask;
                }
                break;
            }
        }
    }
    free( fstr );
    return( rc );
}

#define NUM_FILES   4

int main( int argc, char **argv )
{
    bool    ok;
    int     i;

    setlocale(LC_ALL,"C");
    ok = _LANG_DEFS_OK();
    if( !ok )
        fail( "language index mismatch\n" );
    initTargets();
    for( i = 1; i < argc; i++ ) {
        if( ProcessOptions( argv[i] ) ) {
            ok = false;
            break;
        }
    }
    if( !ok || fno < NUM_FILES ) {
        ok = false;
        dumpUsage();
    } else {
        initUTF8();
        readInputFile();
        assignChainToOptions();
        checkForMissingUsages();
        stripUselessOptions();
        initOptionFields();

        outputInit();
        startParserH();
        outputFN_PROCESS();
        outputFN_INIT();
        outputFN_FINI();
        finishParserH();
        outputUsageH();
        dumpInternational();
        outputFini();
    }
    closeFiles();
    finiTargets();
    if( ok )
        return( EXIT_SUCCESS );
    return( EXIT_FAILURE );
}
